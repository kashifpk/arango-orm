{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to Arango ORM (Python ORM Layer For ArangoDB)</p> <p>arango_orm is a python ORM layer inspired by SQLAlchemy but aimed to work with the multi-model database ArangoDB. It supports accessing both collections and graphs using the ORM. The actual communication with the database is done using python-arango (the database driver for accessing arangodb from python) and object serialization, validation, etc is handled by pydantic.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>python -m pip install arango-orm\n</code></pre>"},{"location":"#differences-from-pre-1x-versions","title":"Differences from Pre 1.x versions","text":"<ul> <li>Based on pydantic2 instead of marshmallow</li> <li>Type hints for better IDE experience</li> <li>Faster and generally simpler</li> </ul>"},{"location":"#native-vs-orm-field-names","title":"Native vs ORM field names","text":"<p>ArangoDB has special field names (<code>_key</code>, <code>_from</code>, <code>_to</code>) but pydantic ignores instance attributes that start with underscore. So internally in arango-orm collections the <code>key_</code> field is <code>key_</code>, <code>_from</code> is <code>from_</code> and <code>_to</code> is <code>to_</code>. However setting the data still works with both styles thanks to pydantic field aliases.</p>"},{"location":"collection-inheritance/","title":"Inheritance","text":"<p>Same collection can be used to store data for more specific entities of the same type. Instead of creating separate collections to store the more specialized data, it can be stored in the same collection and multiple data models can point to the same collection.</p>"},{"location":"collection-inheritance/#example","title":"Example","text":"<pre><code>from arango_orm import Collection\nfrom pydantic import Field\nfrom arango import ArangoClient\nfrom arango_orm import Database\nclient = ArangoClient(hosts='http://localhost:8529')\ntest_db = client.db('test', username='test', password='test')\ndb = Database(test_db)\nclass Citizen(Collection):\n__collection__ = 'citizens'\nkey_: str = Field(..., alias=\"_key\")  # citizen identification number\nname: str\ndob: date\nclass Scientist(Citizen):\ndegress: list[str]\nresearch_field: str\nclass Employee(Citizen):\nbase_salary: int | None = None\ndb.create_collection(Citizen)\nunemployed = Citizen(key_=\"PK-1\", name=\"Sleepy Joe\", dob=\"1990-10-10\")\ndb.add(unemployed)\nemployee = Employee(key_=\"PK-2\", name=\"Regular Joe\", dob=\"1990-11-10\", base_salary=160000)\ndb.add(employee)\nscientist = Scientist(\nkey_=\"PK-3\",\nname=\"Genius Joe\",\ndob=\"1990-12-10\",\ndegress=[\"PhD\", \"Masters\"],\nresearch_field=\"Physics\",\n)\ndb.add(scientist)\nr1: Citizen = test_db.query(Citizen).by_key('PK-1')\nprint(r1.name)  # Sleepy Joe\nprint(r1.dob.isoformat())  # 1990-10-10\nr2: Citizen = test_db.query(Citizen).by_key('PK-2')\nprint(r2.name)  # 'Regular Joe'\nprint(r2.dob.isoformat())  # 1990-11-10\nassert 'base_salary' not in r2.model_dump()  # True\nr3: Citizen = test_db.query(Citizen).by_key('PK-3')\nprint(r3.name)  # Genius Joe\nprint(r3.dob.isoformat())  # 1990-12-10\nassert 'degrees' not in r3.model_dump()\nassert 'research_field' not in r3.model_dump()\ne1: Employee = test_db.query(Employee).by_key(\"PK-2\")\nassert isinstance(e1, Employee)\nassert isinstance(e1, Citizen)\nassert e1.name == 'Regular Joe'\nassert e1.base_salary == 160000\ns1: Scientist = test_db.query(Scientist).by_key(\"PK-3\")\nassert isinstance(s1, Scientist)\nassert isinstance(s1, Citizen)\nassert s1.name == 'Genius Joe'\nassert s1.research_field == 'Physics'\n</code></pre>"},{"location":"collections/","title":"Collections","text":"<p>A collection class definition represents a database collection.</p> <p>Define models to represent your data. Models extend the Collection base class which is an extension of the pydantic <code>BaseModel</code> class. So all functionality provided by pydantic models is available. The same model class can be used for ORM and for defining API request/response structures.</p> <pre><code>from datetime import date\nfrom arango_orm import Collection\nclass Student(Collection):\n__collection__ = 'students'\nname: str   # required field\ndob: date | None = None  # optional field\n</code></pre> <p>All collections have the <code>key_</code> field which translates to the <code>_key</code> field in arangoDB. If no value is provided for <code>key_</code> then one is auto-generated (arango default behavior). If you want to enforce <code>key_</code> to be always provided, you can define the key in your model.</p> <pre><code>from pydantic import Field\nfrom arango_orm import Collection\nclass MyCollection(Collection):\n__collection__ = 'my_collection'\nkey_: str = Field(..., alias=\"_key\")  # required\nname: str\n</code></pre>"},{"location":"collections/#collection-configuration","title":"Collection Configuration","text":""},{"location":"collections/#defining-indexes","title":"Defining Indexes","text":"<p>Define extra indexes for your data using CollectionConfig.</p> <pre><code>class Person(Collection):\n__collection__ = \"people\"\n_collection_config = CollectionConfig(\nindexes=[\nIndexSpec(index_type='hash', fields=[\"_key\"], unique=True, sparse=False),\n]\n)\nname: str\nssn: str\n</code></pre>"},{"location":"events/","title":"Events","text":"<p>The ORM supports data life-cycle events for running code before or after a data modification operation (add/update/delete). Apart from these there is support for creating custom events though in this case the user/developer is responsible for trigerring the events.</p>"},{"location":"events/#built-in-events","title":"Built-in events","text":"<p>There are 6 built-in events that are trigerred automatically and any callback function registered/listening for these gets called. These are:</p> <ul> <li><code>pre_add</code> called before inserting an entity into the database.</li> <li><code>post_add</code> called after inserting an entity into the database.</li> <li><code>pre_update</code> called before updating an entity in the database.</li> <li><code>pre_update</code> called after updating an entity in the database.</li> <li><code>pre_delete</code> called before removing an entity from the database.</li> <li><code>pre_delete</code> called after removing an entity from the database.</li> </ul>"},{"location":"events/#using-events","title":"Using events","text":"<p>To use any event you need to register your callback code (usually a function) against the event. This can be done in two ways. Either using the listen function or the listens_for decorator.</p> <pre><code>from arango import ArangoClient\nfrom arango_orm import Collection, Database\nfrom arango_orm.event import listen, listens_for\nclient = ArangoClient(hosts='http://localhost:8529')\ndb = Database(client.db('test', username='test', password='test'))\nclass Person(Collection):\n__collection__ = 'people'\nname: str\ndef before_add_callback(target: Person, event: str, db: Database):\nprint(f\"About to insert Person {target.name} into the db.\")\nlisten(Person, 'pre_add', before_add_callback)\n@listens_for(\nCollection,\n['pre_add', 'post_add', 'pre_update', 'post_update', 'pre_delete', 'post_delete']\n)\ndef db_audit(target: Collection, event:str, *args, **kwargs):\ndb = kwargs['db']\nprint(f\"{event} on {target} for {db}\")\ndb.create_collection(Person)\ndb.add(Person(name='abc'))\n</code></pre> <p>output:</p> <pre><code>About to insert Person abc into the db.\npre_add on Person(key_=None rev_=None name='abc') for &lt;StandardDatabase test&gt;\npost_add on Person(key_='12644011' rev_=None name='abc') for &lt;StandardDatabase test&gt;\nOut[1]: {'_id': 'people/12644011', '_key': '12644011', '_rev': '_gtrY3JK---'}\n</code></pre>"},{"location":"events/#custom-events","title":"Custom Events","text":"<p>In addition to the built-in events you can create custom events and have code registered against them. However you are responsible for dispatching these event too.</p> <pre><code>from arango_orm import Collection\nfrom arango_orm.event import listen, listens_for, dispatch\nclass Process(Collection):\n__collection__ = 'processes'\npid: int\ncmd: str\ndef sleep(self):\n# actual sleep logic\ndispatch(self, \"gone_to_sleep\")\n@listens_for(Process, 'gone_to_sleep')\ndef monitor_sleep(target: Process, event: str, *args, **kwargs):\nprint(f\"Process {target.pid} has gone to sleep\")\np1 = Process(pid=10, cmd='ls')\np1.sleep()\n# output\nProcess 10 has gone to sleep\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#connecting-to-a-database","title":"Connecting to a database","text":"<pre><code>from arango import ArangoClient\nfrom arango_orm import Database\nclient = ArangoClient(hosts='http://localhost:8529')\ntest_db = client.db('test', username='test', password='test')\ndb = Database(test_db)\n</code></pre>"},{"location":"getting-started/#defining-models","title":"Defining models","text":"<p>Define models to represent your data. Models extend the Collection base class which is an extension of the pydantic <code>BaseModel</code> class. So all functionality provided by pydantic models is available. The same model class can be used for ORM and for defining API request/response structures.</p> <pre><code>from datetime import date\nfrom arango_orm import Collection\nclass Student(Collection):\n__collection__ = 'students'\nname: str   # required field\ndob: date | None = None  # optional field\n</code></pre> <p>All collections have the <code>key_</code> field which translates to the <code>_key</code> field in arangoDB. If no value is provided for <code>key_</code> then one is auto-generated (arango default behavior). If you want to enforce <code>key_</code> to be always provided, you can define the key in your model.</p> <pre><code>from pydantic import Field\nfrom arango_orm import Collection\nclass MyCollection(Collection):\n__collection__ = 'my_collection'\nkey_: str = Field(..., alias=\"_key\")  # required\nname: str\n</code></pre>"},{"location":"getting-started/#creating-collections-in-the-database","title":"Creating collections in the database","text":"<p>To create database collection based on arango-orm model.</p> <pre><code>db.create_collection(Student)\n</code></pre>"},{"location":"getting-started/#adding-records","title":"Adding records","text":"<p>All the methods to create an orm object from a collection depicted below are valid.</p> <pre><code>from datetime import date\n# Recurd using normal field names and ISO Date format which is automatically\n# converted to Date object by pydantic\ns1 = Student(key_='12312', name='Student A', dob='2000-10-25')\n# Use the _key alias instead of key_ and use proper date object.\ns2 = Student(_key='12313', name='Student B', dob=date(year=2000, month=9, day=12))\n# missing key_ is automatically generated\ns3 = Student(name='Student C')\n# Load from a dictionary. dob is None as it is optional.\ns4 = Student(**{'key_': '12315', name='Student D'})\n# insert a single record into the db\ndb.add(s1)\n# insert multiple records\ndb.bulk_add([s2, s3, s4])\nprint(s1._id, s1._key)  # Can use _id and _key they are aliases for id_ and key_\nprint(s2._id, s2._key)\nprint(s3.id_, s3.key_)\nprint(s4.id_, s4.key_)\n</code></pre>"},{"location":"getting-started/#get-total-records-in-collection","title":"Get total records in collection","text":"<pre><code>db.query(Student).count()\n</code></pre>"},{"location":"getting-started/#get-record-by-key","title":"Get record by key","text":"<pre><code>s = db.query(Student).by_key('12312')\n</code></pre>"},{"location":"getting-started/#updating-records","title":"Updating records","text":"<pre><code>s = db.query(Student).by_key('12312')\ns.name = 'Anonymous'\ndb.update(s)\n</code></pre>"},{"location":"getting-started/#deleting-records","title":"Deleting records","text":"<pre><code>s = db.query(Student).by_key('12312')\ndb.delete(s)\n</code></pre>"},{"location":"getting-started/#get-all-records-in-collection","title":"Get all records in collection","text":"<pre><code>students = db.query(Student).all()\n</code></pre>"},{"location":"getting-started/#delete-all-records-in-collection","title":"Delete all records in collection","text":"<pre><code>db.query(Student).delete()\n</code></pre>"},{"location":"getting-started/#get-first-record-matching-the-query","title":"Get first record matching the query","text":"<pre><code>first_student = db.query(Student).first()\n</code></pre>"},{"location":"getting-started/#get-an-iterator-for-the-query","title":"Get an iterator for the query","text":"<p>If you don't want to fetch all records from large collections, use an iterator to be more memory efficient.</p> <pre><code>for rec in db.query(Student).iterator():\nprint(rec.key_)\n</code></pre>"},{"location":"graphs/","title":"Graphs","text":"<p>One of the biggest strengths of a multi-model database like ArangoDB is the ability to work with graphs. Graphs are suitable when your data is highly connected (think too many relationships for a relational database to handle). A graph is a collection of vertices (collections) and edges (relations). Edges connect vertices and then the graph can be traversed from one vertix to others via connecting edges.</p> <p>In arango-orm vertices are classes that inherit from the Collection class while edges are classes that inherit from Relation class. Working with graphs involves creating collection classes and optionally Edge/Relation classes. Users can use the built-in Relation class for specifying relations but if relations need to contain extra attributes then it's required to create a sub-class of Relation class. Graph functionality is explained below with the help of a university graph example containing students, teachers, subjects and the areas where students and teachers reside in.</p> <p>First we create some collections and relationships</p> <pre><code>from typing import Literal\nfrom arango_orm import Collection, Relation, Graph, GraphConnection\nclass Student(Collection):\n__collection__ = 'students'\nname: str\nage: int | None = None\ndef __str__(self):\nreturn \"&lt;Student({})&gt;\".format(self.name)\nclass Teacher(Collection):\n__collection__ = 'teachers'\nname: str\ndef __str__(self):\nreturn \"&lt;Teacher({})&gt;\".format(self.name)\nclass Subject(Collection):\n__collection__ = 'subjects'\nname: str\ncredit_hours: int\nhas_labs: bool = True\ndef __str__(self):\nreturn \"&lt;Subject({})&gt;\".format(self.name)\nclass Area(Collection):\n__collection__ = 'areas'\nclass SpecializesIn(Relation):\n__collection__ = 'specializes_in'\nexpertise_level: Literal[\"expert\", \"medium\", \"basic\"]\ndef __str__(self):\nreturn \"&lt;SpecializesIn(_key={}, expertise_level={}, _from={}, _to={})&gt;\".format(\nself.key_, self.expertise_level, self._from, self._to)\n</code></pre> <p>Next we sub-class the Graph class to specify the relationships between the various collections</p> <pre><code>class UniversityGraph(Graph):\n__graph__ = 'university_graph'\ngraph_connections = [\n# Using general Relation class for relationship\nGraphConnection(Student, Relation(\"studies\"), Subject),\nGraphConnection(Teacher, Relation(\"teaches\"), Subject),\n# Using specific classes for vertex and edges\nGraphConnection(Teacher, SpecializesIn, Subject),\nGraphConnection([Teacher, Student], Relation(\"resides_in\"), Area)\n]\n</code></pre> <p>Now it's time to create the graph. Note that we don't need to create the collections individually, creating the graph will create all collections that it contains</p> <pre><code>from arango import ArangoClient\nfrom arango_orm.database import Database\nclient = ArangoClient(hosts='http://localhost:8529')\ntest_db = client.db('test', username='test', password='test')\ndb = Database(test_db)\nuni_graph = UniversityGraph(connection=db)\ndb.create_graph(uni_graph)\n</code></pre> <p>Now the graph and all it's collections have been created, we can verify their existence:</p> <pre><code>[c['name'] for c in db.collections()]\ndb.graphs()\n</code></pre> <p>Now let's insert some data into our graph:</p> <pre><code>students_data = [\nStudent(_key='S1001', name='John Wayne', age=30),\nStudent(_key='S1002', name='Lilly Parker', age=22),\nStudent(_key='S1003', name='Cassandra Nix', age=25),\nStudent(_key='S1004', name='Peter Parker', age=20)\n]\nteachers_data = [\nTeacher(_key='T001', name='Bruce Wayne'),\nTeacher(_key='T002', name='Barry Allen'),\nTeacher(_key='T003', name='Amanda Waller')\n]\nsubjects_data = [\nSubject(_key='ITP101', name='Introduction to Programming', credit_hours=4, has_labs=True),\nSubject(_key='CS102', name='Computer History', credit_hours=3, has_labs=False),\nSubject(_key='CSOOP02', name='Object Oriented Programming', credit_hours=3, has_labs=True),\n]\nareas_data = [\nArea(_key=\"Gotham\"),\nArea(_key=\"Metropolis\"),\nArea(_key=\"StarCity\")\n]\nfor s in students_data:\ndb.add(s)\nfor t in teachers_data:\ndb.add(t)\nfor s in subjects_data:\ndb.add(s)\nfor a in areas_data:\ndb.add(a)\n</code></pre> <p>Next let's add some relations, we can add relations by manually adding the relation/edge record into the edge collection, like:</p> <pre><code>db.add(SpecializesIn(_from=\"teachers/T001\", _to=\"subjects/ITP101\", expertise_level=\"medium\"))\n</code></pre> <p>Or we can use the graph object's relation method to generate a relation document from given objects:</p> <pre><code>gotham = db.query(Area).by_key(\"Gotham\")\nmetropolis = db.query(Area).by_key(\"Metropolis\")\nstar_city = db.query(Area).by_key(\"StarCity\")\njohn_wayne = db.query(Student).by_key(\"S1001\")\nlilly_parker = db.query(Student).by_key(\"S1002\")\ncassandra_nix = db.query(Student).by_key(\"S1003\")\npeter_parker = db.query(Student).by_key(\"S1004\")\nintro_to_prog = db.query(Subject).by_key(\"ITP101\")\ncomp_history = db.query(Subject).by_key(\"CS102\")\noop = db.query(Subject).by_key(\"CSOOP02\")\nbarry_allen = db.query(Teacher).by_key(\"T002\")\nbruce_wayne = db.query(Teacher).by_key(\"T001\")\namanda_waller = db.query(Teacher).by_key(\"T003\")\ndb.add(uni_graph.relation(peter_parker, Relation(\"studies\"), oop))\ndb.add(uni_graph.relation(peter_parker, Relation(\"studies\"), intro_to_prog))\ndb.add(uni_graph.relation(john_wayne, Relation(\"studies\"), oop))\ndb.add(uni_graph.relation(john_wayne, Relation(\"studies\"), comp_history))\ndb.add(uni_graph.relation(lilly_parker, Relation(\"studies\"), intro_to_prog))\ndb.add(uni_graph.relation(lilly_parker, Relation(\"studies\"), comp_history))\ndb.add(uni_graph.relation(cassandra_nix, Relation(\"studies\"), oop))\ndb.add(uni_graph.relation(cassandra_nix, Relation(\"studies\"), intro_to_prog))\ndb.add(uni_graph.relation(barry_allen, SpecializesIn(expertise_level=\"expert\"), oop))\ndb.add(uni_graph.relation(barry_allen, SpecializesIn(expertise_level=\"expert\"), intro_to_prog))\ndb.add(uni_graph.relation(bruce_wayne, SpecializesIn(expertise_level=\"medium\"), oop))\ndb.add(uni_graph.relation(bruce_wayne, SpecializesIn(expertise_level=\"expert\"), comp_history))\ndb.add(uni_graph.relation(amanda_waller, SpecializesIn(expertise_level=\"basic\"), intro_to_prog))\ndb.add(uni_graph.relation(amanda_waller, SpecializesIn(expertise_level=\"medium\"), comp_history))\ndb.add(uni_graph.relation(bruce_wayne, Relation(\"teaches\"), oop))\ndb.add(uni_graph.relation(barry_allen, Relation(\"teaches\"), intro_to_prog))\ndb.add(uni_graph.relation(amanda_waller, Relation(\"teaches\"), comp_history))\ndb.add(uni_graph.relation(bruce_wayne, Relation(\"resides_in\"), gotham))\ndb.add(uni_graph.relation(barry_allen, Relation(\"resides_in\"), star_city))\ndb.add(uni_graph.relation(amanda_waller, Relation(\"resides_in\"), metropolis))\ndb.add(uni_graph.relation(john_wayne, Relation(\"resides_in\"), gotham))\ndb.add(uni_graph.relation(lilly_parker, Relation(\"resides_in\"), metropolis))\ndb.add(uni_graph.relation(cassandra_nix, Relation(\"resides_in\"), star_city))\ndb.add(uni_graph.relation(peter_parker, Relation(\"resides_in\"), metropolis))\n</code></pre> <p>With our graph populated with some sample data, let's explore the ways we can work with the graph.</p>"},{"location":"graphs/#expanding-documents","title":"Expanding Documents","text":"<p>We can expand any Collection (not Relation) object to access the data that is linked to it. We can sepcify which links ('inbound', 'outbound', 'any') to expand and the depth to which those should be expanded to. Let's see all immediate connections that Bruce Wayne has in our graph:</p> <pre><code>bruce = db.query(Teacher).by_key(\"T001\")\nuni_graph.expand(bruce, depth=1, direction='any')\n</code></pre> <p>Graph expansion on an object adds a <code>_relations</code> dictionary that contains all the relations for the object according to the expansion criteria:</p> <pre><code>bruce._relations\n# Returns:\n{\n'resides_in': [&lt;Relation(_key=4205290, _from=teachers/T001, _to=areas/Gotham)&gt;],\n'specializes_in': [&lt;SpecializesIn(_key=4205114, expertise_level=medium, _from=teachers/T001, _to=subjects/ITP101)&gt;,\n&lt;SpecializesIn(_key=4205271, expertise_level=expert, _from=teachers/T001, _to=subjects/CS102)&gt;,\n&lt;SpecializesIn(_key=4205268, expertise_level=medium, _from=teachers/T001, _to=subjects/CSOOP02)&gt;],\n'teaches': [&lt;Relation(_key=4205280, _from=teachers/T001, _to=subjects/CSOOP02)&gt;]\n}\n</code></pre> <p>We can use _from and _to of a relation object to access the id's for both sides of the link. We also have _object_from and _object_to to access the objects on both sides, for example:</p> <pre><code>bruce._relations['resides_in'][0]._object_from.name\n# 'Bruce Wayne'\nbruce._relations['resides_in'][0]._object_to._key\n# 'Gotham'\n</code></pre> <p>There is also a special attribute called <code>_next</code> that allows accessing the other side of the relationship irrespective of the relationship direction. For example, for outbound relationships the <code>_object_from</code> contains the source object while for inbound_relationships <code>_object_to</code> contains the source object. But if we're only interested in traversal of the graph then it's more useful at times to access the other side of the relationship w.r.t the current object irrespective of it's direction:</p> <pre><code>bruce._relations['resides_in'][0]._next._key\n# 'Gotham'\n</code></pre> <p>Let's expand the bruce object to 2 levels and see <code>_next</code> in more action:</p> <pre><code>uni_graph.expand(bruce, depth=2)\n# All relations of the area where bruce resides in\nbruce._relations['resides_in'][0]._object_to._relations\n# -&gt; {'resides_in': [&lt;Relation(_key=4205300, _from=students/S1001, _to=areas/Gotham)&gt;]}\n# Name of the student that resides in the same area as bruce\nbruce._relations['resides_in'][0]._object_to._relations['resides_in'][0]._object_from.name\n# 'John Wayne'\n# The same action using _next without worrying about direction\nbruce._relations['resides_in'][0]._next._relations['resides_in'][0]._next.name\n# 'John Wayne'\n# Get names of all people that reside in the same area and Bruce Wayne\n[p._next.name for p in bruce._relations['resides_in'][0]._next._relations['resides_in']]\n# ['John Wayne']\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#database","title":"Database","text":"<p>             Bases: <code>StandardDatabase</code></p> <p>Serves similar to SQLAlchemy's session object with the exception that it also allows creating and dropping collections etc.</p> Source code in <code>arango_orm/database.py</code> <pre><code>class Database(ArangoDatabase):\n\"\"\"\n    Serves similar to SQLAlchemy's session object with the exception that it\n    also allows creating and dropping collections etc.\n    \"\"\"\ndef __init__(self, db: ArangoDatabase):\n\"\"\"Create database instance.\"\"\"\nself._db: ArangoDatabase = db\nsuper(Database, self).__init__(db._conn)\n#         super(Database, self).__init__(\n#             connection=connection,\n#             executor=DefaultExecutor(connection)\n# )\ndef _verify_collection(self, col) -&gt; bool:\n\"\"\"\n        Verifies that col is a collection class or object.\n        \"\"\"\nCollectionClass = None\nif isclass(col):\nCollectionClass = col\nelse:\nCollectionClass = col.__class__\nif CollectionClass is Collection or issubclass(CollectionClass, Collection):\nreturn col.__collection__ is not None\nreturn False\ndef _verify_relation(self, col) -&gt; bool:\n\"\"\"\n        Verifies that col is a relation class or object.\n        \"\"\"\nCollectionClass = None\nif isclass(col):\nCollectionClass = col\nelse:\nCollectionClass = col.__class__\nif CollectionClass is Relation or issubclass(CollectionClass, Relation):\nreturn col.__collection__ is not None\nreturn False\ndef _entity_pre_process(self, data: dict) -&gt; None:\n\"Clean up data dict before add/update into the db.\"\nfor k in (\"_key\", \"_rev\"):\nif k in data and data[k] is None:\ndel data[k]\ndef _entity_post_process(self, entity: Collection, result: dict) -&gt; None:\n\"Update entity after add/update.\"\nfor k in ((\"key_\", \"_key\"), (\"rev_\", \"_rev\")):\nif result.get(k[1], None) is not None:\nsetattr(entity, k[0], result[k[1]])\nentity._dirty.remove(k[0])\ndef has_collection(self, collection):\n\"Confirm that the given collection class or collection name exists in the db\"\ncollection_name = None\nif isclass(collection) and hasattr(collection, \"__collection__\"):\ncollection_name = collection.__collection__\nelif isinstance(collection, str):\ncollection_name = collection\nassert collection_name is not None\nreturn self._db.has_collection(collection_name)\ndef create_collection(self, collection: Collection):\n\"Create a collection\"\nself._verify_collection(collection)\ncol_args = {}\nif \"col_args\" in collection._collection_config:\ncol_args = collection._collection_config[\"col_args\"]\nif self._verify_relation(collection) and \"edge\" not in col_args:\ncol_args[\"edge\"] = True\ncol = super(Database, self).create_collection(name=collection.__collection__, **col_args)\nif \"indexes\" in collection._collection_config:\nfor index in collection._collection_config[\"indexes\"]:\n# index_type: Literal[\"hash\", \"fulltext\", \"skiplist\", \"geo\", \"persistent\", \"ttl\"]\n# fields: list[str]\n# unique: bool\n# sparse: bool\nindex_create_method_name = \"add_{}_index\".format(index[\"index_type\"])\nd = deepcopy(index)\ndel d[\"index_type\"]\n# create the index\ngetattr(col, index_create_method_name)(**d)\ndef drop_collection(self, collection):\n\"Drop a collection\"\nself._verify_collection(collection)\nsuper(Database, self).delete_collection(name=collection.__collection__)\ndef has(self, collection, key):\n\"\"\"Check if the document with key exists in the given collection.\"\"\"\nreturn self._db.collection(collection.__collection__).has(key)\ndef exists(self, document):\n\"\"\"\n        Check if document exists in database.\n        Similar to has but takes in a document object and searches\n        using it's _key.\n        \"\"\"\nreturn self._db.collection(document.__collection__).has(document.key_)\ndef add(self, entity: Collection, if_present: Literal[\"ignore\", \"update\"] = None):\n\"\"\"\n        Add a record to a collection.\n        :param if_present: Can be None, 'ignore' or 'update'.\n            In case of None, if the document is already present then\n            arango.exceptions.DocumentInsertError is raised. 'ignore' ignores\n            raising the exception. 'update' updates the document if it already\n            exists.\n        \"\"\"\nassert if_present in [None, \"ignore\", \"update\"]\nif if_present and getattr(entity, \"key_\", None):\n# for these cases, first check if document exists\nif self.exists(entity):\nif if_present == \"ignore\":\nsetattr(entity, \"_db\", self)\nreturn entity\nelif if_present == \"update\":\nreturn self.update(entity)\ndata_json = entity.model_dump(mode=\"json\", by_alias=True)\nself._entity_pre_process(data_json)\ndispatch(entity, \"pre_add\", db=self)\ncollection = self._db.collection(entity.__collection__)\nsetattr(entity, \"_db\", self)\nres = collection.insert(data_json)\nself._entity_post_process(entity, res)\nentity._dirty.clear()\ndispatch(entity, \"post_add\", db=self, result=entity)\nreturn entity\ndef bulk_add(self, entity_list, only_dirty=False, **kwargs):\n\"\"\"\n        Add all provided documents, attaching generated _key to entities if generated\n        :param entity_list: List of Collection/Relationship objects\n        :return: { collection_name : {\n                collection_model: Collection class,\n                entity_obj_list: Collection instance,\n                entity_dict_list: dict\n                }\n            }\n        \"\"\"\ncollections = {}\nfor entity in entity_list:\ncollection_model = self._db.collection(entity.__collection__)\ndata = entity.model_dump(mode=\"json\", by_alias=True)\nif only_dirty:\nif not entity._dirty:\nreturn entity\ndata = {k: v for k, v in data.items() if k == \"_key\" or k in entity._dirty}\n# Clean data dict\nself._entity_pre_process(data)\ndispatch(entity, \"pre_update\", db=self)\ncollection_dict = collections.get(entity.__collection__, dict())\nentity_dict_list = collection_dict.get(\"entity_dict_list\", list())\nentity_obj_list = collection_dict.get(\"entity_obj_list\", list())\nentity_dict_list.append(data)\nentity_obj_list.append(entity)\ncollection_dict[\"entity_dict_list\"] = entity_dict_list\ncollection_dict[\"entity_obj_list\"] = entity_obj_list\ncollection_dict[\"collection_model\"] = collection_model\ncollections[entity.__collection__] = collection_dict\nsetattr(entity, \"_db\", self)\nentity._dirty.clear()\nfor collection, data in collections.items():\ncollection_model = data.get(\"collection_model\")\nentity_dict_list = data.get(\"entity_dict_list\")\nentity_obj_list = data.get(\"entity_obj_list\")\nres = collection_model.insert_many(entity_dict_list, **kwargs)\nfor num, entity in enumerate(entity_obj_list, start=0):\nentity._dirty.clear()\nself._entity_post_process(entity, res[num])\ndispatch(entity, \"post_add\", db=self, result=entity)\nreturn collections\ndef delete(self, entity: Collection, **kwargs):\n\"\"\"Delete given document.\"\"\"\ndispatch(entity, \"pre_delete\", db=self)\ncollection = self._db.collection(entity.__collection__)\ncollection.delete(entity.key_, **kwargs)\ndispatch(entity, \"post_delete\", db=self, result=entity)\nreturn entity\ndef bulk_delete(self, entity_list, **kwargs):\n\"\"\"Bulk delete utility, based on delete method. Return a list of results.\"\"\"\nres = []\nfor entity in entity_list:\nres.append(self.delete(entity, **kwargs))\nreturn res\ndef update(self, entity, only_dirty=False, **kwargs):\n\"Update given document\"\ncollection = self._db.collection(entity.__collection__)\ndata = {}\nif only_dirty:\nif not entity._dirty:\nreturn entity\ndispatch(entity, \"pre_update\", db=self)  # In case of updates to fields\ndata = {\nk: v\nfor k, v in entity.model_dump(mode=\"json\", by_alias=True).items()\nif k == \"_key\" or k in entity._dirty\n}\nelse:\ndispatch(entity, \"pre_update\", db=self)\ndata = entity.model_dump(mode=\"json\", by_alias=True)\nsetattr(entity, \"_db\", self)\nself._entity_pre_process(data)\nres = collection.update(data, **kwargs)\nentity._dirty.clear()\nself._entity_post_process(entity, res)\ndispatch(entity, \"post_update\", db=self, result=entity)\nreturn entity\ndef bulk_update(self, entity_list, only_dirty=False, **kwargs):\n\"\"\"\n        Update all provided documents\n        :param entity_list: List of Collection/Relationship objects\n        :return: { collection_name : {\n                collection_model: Collection class,\n                entity_obj_list: Collection instance,\n                entity_dict_list: dict\n                }\n            }\n        \"\"\"\ncollections = {}\nfor entity in entity_list:\ncollection_model = self._db.collection(entity.__collection__)\ndata = {}\nif only_dirty:\nif not entity._dirty:\nreturn entity\ndispatch(entity, \"pre_update\", db=self)  # In case of updates to fields\ndata = {\nk: v\nfor k, v in entity.model_dump(mode=\"json\", by_alias=True).items()\nif k == \"_key\" or k in entity._dirty\n}\nelse:\ndispatch(entity, \"pre_update\", db=self)\ndata = entity.model_dump(mode=\"json\", by_alias=True)\n# dispatch(entity, 'pre_update', db=self)\ncollection_dict = collections.get(entity.__collection__, dict())\nentity_dict_list = collection_dict.get(\"entity_dict_list\", list())\nentity_obj_list = collection_dict.get(\"entity_obj_list\", list())\nself._entity_pre_process(data)\nentity_dict_list.append(data)\nentity_obj_list.append(entity)\ncollection_dict[\"entity_dict_list\"] = entity_dict_list\ncollection_dict[\"entity_obj_list\"] = entity_obj_list\ncollection_dict[\"collection_model\"] = collection_model\ncollections[entity.__collection__] = collection_dict\nsetattr(entity, \"_db\", self)\n# entity._dirty.clear()\nfor _, data in collections.items():\ncollection_model = data.get(\"collection_model\")\nentity_dict_list = data.get(\"entity_dict_list\")\nentity_obj_list = data.get(\"entity_obj_list\")\nres = collection_model.update_many(entity_dict_list, **kwargs)\nfor num, entity in enumerate(entity_obj_list, start=0):\nentity._dirty.clear()\nself._entity_post_process(entity, res[num])\ndispatch(entity, \"post_update\", db=self, result=entity)\nreturn collections\ndef query(self, CollectionClass) -&gt; Query:\n\"Query given collection\"\nreturn Query(CollectionClass, self)\ndef create_graph(self, graph_object: Graph, **kwargs):\n\"\"\"\n        Create a named graph from given graph object\n        Optionally can provide a list of collection names as ignore_collections\n        so those collections are not created\n        \"\"\"\ngraph_edge_definitions = []\n# Create collections manually here so we also create indices\n# defined within the collection class. If we let the create_graph\n# call create the collections, it won't create the indices\nfor _, col_obj in graph_object.vertices.items():\nif (\n\"ignore_collections\" in kwargs\nand col_obj.__collection__ in kwargs[\"ignore_collections\"]\n):\ncontinue\ntry:\nself.create_collection(col_obj)\nexcept Exception:\nlog.warning(\n\"Error creating collection %s, it probably already exists\",\ncol_obj.__collection__,\n)\nfor _, rel_obj in graph_object.edges.items():\nif (\n\"ignore_collections\" in kwargs\nand rel_obj.__collection__ in kwargs[\"ignore_collections\"]\n):\ncontinue\ntry:\nself.create_collection(rel_obj)\nexcept Exception:\nlog.warning(\n\"Error creating edge collection %s, it probably already exists\",\nrel_obj.__collection__,\n)\nfor rel_name, relation_obj in graph_object.edges.items():\ncols_from = graph_object.edge_cols_from[rel_name]\ncols_to = graph_object.edge_cols_to[rel_name]\nfrom_col_names = [col.__collection__ for col in cols_from]\nto_col_names = [col.__collection__ for col in cols_to]\ngraph_edge_definitions.append(\n{\n\"edge_collection\": relation_obj.__collection__,\n\"from_vertex_collections\": from_col_names,\n\"to_vertex_collections\": to_col_names,\n}\n)\nself._db.create_graph(graph_object.__graph__, graph_edge_definitions)\ndef drop_graph(self, graph_object, drop_collections=True, **kwargs):\n\"\"\"\n        Drop a graph.\n        If drop_collections is True, drop all vertices and edges\n        too. Optionally can provide a list of collection names as\n        ignore_collections so those collections are not dropped\n        \"\"\"\nself._db.delete_graph(\ngraph_object.__graph__,\nignore_missing=True,\ndrop_collections=drop_collections,\n)\ndef update_graph(self, graph_object: Graph, graph_info=None):\n\"\"\"\n        Update existing graph object by adding collections and edge collections\n        that are present in graph definition but not present within the graph\n        in the database.\n        Note: We delete edge definitions if they no longer exist in the graph\n        class but we don't drop collections\n        \"\"\"\nif graph_info is None:\ngraph_info = self._get_graph_info(graph_object)\n# Create collections manually here so we also create indices\n# defined within the collection class. If we let the create_graph\n# call create the collections, it won't create the indices\nexisting_collection_names = [c[\"name\"] for c in self.collections()]\nfor _, col_obj in graph_object.vertices.items():\ntry:\nif col_obj.__collection__ in existing_collection_names:\nlog.debug(\"Collection %s already exists\", col_obj.__collection__)\ncontinue\nlog.info(\"+ Creating collection %s\", col_obj.__collection__)\nself.create_collection(col_obj)\nexcept Exception:\nlog.warning(\n\"Error creating collection %s, it probably already exists\",\ncol_obj.__collection__,\n)\nfor _, rel_obj in graph_object.edges.items():\ntry:\nif rel_obj.__collection__ in existing_collection_names:\nlog.debug(\"Collection %s already exists\", rel_obj.__collection__)\ncontinue\nlog.info(\"+ Creating edge collection %s\", rel_obj.__collection__)\nself.create_collection(rel_obj, edge=True)\nexcept Exception:\nlog.warning(\n\"Error creating edge collection %s, it probably already exists\",\nrel_obj.__collection__,\n)\nexisting_edges = dict(\n[(e[\"edge_collection\"], e) for e in graph_object._graph.edge_definitions()]\n)\nfor rel_name, relation in graph_object.edges.items():\ncols_from = graph_object.edge_cols_from[rel_name]\ncols_to = graph_object.edge_cols_to[rel_name]\nfrom_col_names = [col.__collection__ for col in cols_from]\nto_col_names = [col.__collection__ for col in cols_to]\nedge_definition = {\n\"edge_collection\": relation.__collection__,\n\"from_vertex_collections\": from_col_names,\n\"to_vertex_collections\": to_col_names,\n}\n# if edge does not already exist, create it\nif edge_definition[\"edge_collection\"] not in existing_edges:\nlog.info(\"  + creating graph edge definition: %r\", edge_definition)\ngraph_object._graph.create_edge_definition(**edge_definition)\nelse:\n# if edge definition exists, see if it needs updating\n# compare edges\nif not self._is_same_edge(\nedge_definition,\nexisting_edges[edge_definition[\"edge_collection\"]],\n):\n# replace_edge_definition\nlog.info(\n\"  graph edge definition modified, updating:\\n new: %r\\n old: %r\",\nedge_definition,\nexisting_edges[edge_definition[\"edge_collection\"]],\n)\ngraph_object._graph.replace_edge_definition(**edge_definition)\n# Remove any edge definitions that are present in DB but not in graph definition\ngraph_connections = dict(\n[(gc.relation.__collection__, gc) for gc in graph_object.graph_connections]\n)\nfor edge_name, ee in existing_edges.items():\nif edge_name not in graph_connections:\nlog.warning(\n\"  - dropping edge no longer present in graph definition. \"\n\"Please drop the edge and vertex collections manually if you no \"\n\"longer need them: \\n%s\",\nee,\n)\ngraph_object._graph.delete_edge_definition(edge_name)\ndef _is_same_edge(self, e1, e2):\n\"\"\"\n        Compare given edge dicts and return True if both dicts have same keys and values else\n        return False\n        \"\"\"\n# {'name': 'dns_info', 'to_collections': ['domains'], 'from_collections': ['dns_records']}\nassert e1[\"edge_collection\"] == e2[\"edge_collection\"]\nif len(e1[\"to_vertex_collections\"]) != len(e2[\"to_vertex_collections\"]) or len(\ne1[\"from_vertex_collections\"]\n) != len(e2[\"from_vertex_collections\"]):\nreturn False\nelse:\n# if same length compare values\nfor cname in e1[\"to_vertex_collections\"]:\nif cname not in e2[\"to_vertex_collections\"]:\nreturn False\nfor cname in e1[\"from_vertex_collections\"]:\nif cname not in e2[\"from_vertex_collections\"]:\nreturn False\nreturn True\ndef _get_graph_info(self, graph_obj):\ngraphs_info = self.graphs()\nfor gi in graphs_info:\nif gi[\"name\"] == graph_obj.__graph__:\nreturn gi\nreturn None\ndef create_all(self, db_objects):\n\"\"\"\n        Create all objects (collections, relations and graphs).\n        Create all objects present in the db_objects list.\n        \"\"\"\n# Collect all graphs\ngraph_objs = [obj for obj in db_objects if hasattr(obj, \"__graph__\")]\nfor graph_obj in graph_objs:\ngraph_info = self._get_graph_info(graph_obj)\nif not graph_info:\n# graph does not exist, create it\nlog.info(\"Creating graph %s\", graph_obj.__graph__)\ngraph_instance = graph_obj(connection=self)\nself.create_graph(graph_instance)\nelse:\n# Graph exists, determine changes and update graph accordingly\nlog.debug(\"Graph %s already exists\", graph_obj.__graph__)\ngraph_instance = graph_obj(connection=self)\nself.update_graph(graph_instance, graph_info)\nexclude_collections = [c[\"name\"] for c in self._db.collections()]\nfor obj in db_objects:\nif hasattr(obj, \"__bases__\") and Collection in obj.__bases__:\nif obj.__collection__ not in exclude_collections:\nlog.info(\"Creating collection %s\", obj.__collection__)\nself.create_collection(obj)\nelse:\nlog.debug(\"Collection %s already exists\", obj.__collection__)\ndef drop_all(self, db_objects):\n\"\"\"\n        Drop all objects (collections, relations and graphs).\n        Drop all objects present in the db_objects list.\n        \"\"\"\n# Collect all graphs\ngraph_objs = [obj for obj in db_objects if hasattr(obj, \"__graph__\")]\nfor graph_obj in graph_objs:\ngraph_info = self._get_graph_info(graph_obj)\nif graph_info:\n# graph exists, drop it\nlog.info(\"Dropping graph %s\", graph_obj.__graph__)\ngraph_instance = graph_obj(connection=self)\nself.drop_graph(graph_instance)\nelse:\n# Graph exists, determine changes and update graph accordingly\nlog.debug(\"Graph %s does not exist\", graph_obj.__graph__)\nfor obj in db_objects:\nif hasattr(obj, \"__bases__\") and Collection in obj.__bases__:\ntry:\nself.drop_collection(obj)\nexcept CollectionDeleteError:\nlog.debug(\n\"Not deleting missing collection: %s\",\nobj.__collection__,\n)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.__init__","title":"<code>__init__(db)</code>","text":"<p>Create database instance.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def __init__(self, db: ArangoDatabase):\n\"\"\"Create database instance.\"\"\"\nself._db: ArangoDatabase = db\nsuper(Database, self).__init__(db._conn)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.add","title":"<code>add(entity, if_present=None)</code>","text":"<p>Add a record to a collection.</p> <p>:param if_present: Can be None, 'ignore' or 'update'.     In case of None, if the document is already present then     arango.exceptions.DocumentInsertError is raised. 'ignore' ignores     raising the exception. 'update' updates the document if it already     exists.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def add(self, entity: Collection, if_present: Literal[\"ignore\", \"update\"] = None):\n\"\"\"\n    Add a record to a collection.\n    :param if_present: Can be None, 'ignore' or 'update'.\n        In case of None, if the document is already present then\n        arango.exceptions.DocumentInsertError is raised. 'ignore' ignores\n        raising the exception. 'update' updates the document if it already\n        exists.\n    \"\"\"\nassert if_present in [None, \"ignore\", \"update\"]\nif if_present and getattr(entity, \"key_\", None):\n# for these cases, first check if document exists\nif self.exists(entity):\nif if_present == \"ignore\":\nsetattr(entity, \"_db\", self)\nreturn entity\nelif if_present == \"update\":\nreturn self.update(entity)\ndata_json = entity.model_dump(mode=\"json\", by_alias=True)\nself._entity_pre_process(data_json)\ndispatch(entity, \"pre_add\", db=self)\ncollection = self._db.collection(entity.__collection__)\nsetattr(entity, \"_db\", self)\nres = collection.insert(data_json)\nself._entity_post_process(entity, res)\nentity._dirty.clear()\ndispatch(entity, \"post_add\", db=self, result=entity)\nreturn entity\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.bulk_add","title":"<code>bulk_add(entity_list, only_dirty=False, **kwargs)</code>","text":"<p>Add all provided documents, attaching generated _key to entities if generated :param entity_list: List of Collection/Relationship objects :return: { collection_name : {         collection_model: Collection class,         entity_obj_list: Collection instance,         entity_dict_list: dict         }     }</p> Source code in <code>arango_orm/database.py</code> <pre><code>def bulk_add(self, entity_list, only_dirty=False, **kwargs):\n\"\"\"\n    Add all provided documents, attaching generated _key to entities if generated\n    :param entity_list: List of Collection/Relationship objects\n    :return: { collection_name : {\n            collection_model: Collection class,\n            entity_obj_list: Collection instance,\n            entity_dict_list: dict\n            }\n        }\n    \"\"\"\ncollections = {}\nfor entity in entity_list:\ncollection_model = self._db.collection(entity.__collection__)\ndata = entity.model_dump(mode=\"json\", by_alias=True)\nif only_dirty:\nif not entity._dirty:\nreturn entity\ndata = {k: v for k, v in data.items() if k == \"_key\" or k in entity._dirty}\n# Clean data dict\nself._entity_pre_process(data)\ndispatch(entity, \"pre_update\", db=self)\ncollection_dict = collections.get(entity.__collection__, dict())\nentity_dict_list = collection_dict.get(\"entity_dict_list\", list())\nentity_obj_list = collection_dict.get(\"entity_obj_list\", list())\nentity_dict_list.append(data)\nentity_obj_list.append(entity)\ncollection_dict[\"entity_dict_list\"] = entity_dict_list\ncollection_dict[\"entity_obj_list\"] = entity_obj_list\ncollection_dict[\"collection_model\"] = collection_model\ncollections[entity.__collection__] = collection_dict\nsetattr(entity, \"_db\", self)\nentity._dirty.clear()\nfor collection, data in collections.items():\ncollection_model = data.get(\"collection_model\")\nentity_dict_list = data.get(\"entity_dict_list\")\nentity_obj_list = data.get(\"entity_obj_list\")\nres = collection_model.insert_many(entity_dict_list, **kwargs)\nfor num, entity in enumerate(entity_obj_list, start=0):\nentity._dirty.clear()\nself._entity_post_process(entity, res[num])\ndispatch(entity, \"post_add\", db=self, result=entity)\nreturn collections\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.bulk_delete","title":"<code>bulk_delete(entity_list, **kwargs)</code>","text":"<p>Bulk delete utility, based on delete method. Return a list of results.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def bulk_delete(self, entity_list, **kwargs):\n\"\"\"Bulk delete utility, based on delete method. Return a list of results.\"\"\"\nres = []\nfor entity in entity_list:\nres.append(self.delete(entity, **kwargs))\nreturn res\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.bulk_update","title":"<code>bulk_update(entity_list, only_dirty=False, **kwargs)</code>","text":"<p>Update all provided documents :param entity_list: List of Collection/Relationship objects :return: { collection_name : {         collection_model: Collection class,         entity_obj_list: Collection instance,         entity_dict_list: dict         }     }</p> Source code in <code>arango_orm/database.py</code> <pre><code>def bulk_update(self, entity_list, only_dirty=False, **kwargs):\n\"\"\"\n    Update all provided documents\n    :param entity_list: List of Collection/Relationship objects\n    :return: { collection_name : {\n            collection_model: Collection class,\n            entity_obj_list: Collection instance,\n            entity_dict_list: dict\n            }\n        }\n    \"\"\"\ncollections = {}\nfor entity in entity_list:\ncollection_model = self._db.collection(entity.__collection__)\ndata = {}\nif only_dirty:\nif not entity._dirty:\nreturn entity\ndispatch(entity, \"pre_update\", db=self)  # In case of updates to fields\ndata = {\nk: v\nfor k, v in entity.model_dump(mode=\"json\", by_alias=True).items()\nif k == \"_key\" or k in entity._dirty\n}\nelse:\ndispatch(entity, \"pre_update\", db=self)\ndata = entity.model_dump(mode=\"json\", by_alias=True)\n# dispatch(entity, 'pre_update', db=self)\ncollection_dict = collections.get(entity.__collection__, dict())\nentity_dict_list = collection_dict.get(\"entity_dict_list\", list())\nentity_obj_list = collection_dict.get(\"entity_obj_list\", list())\nself._entity_pre_process(data)\nentity_dict_list.append(data)\nentity_obj_list.append(entity)\ncollection_dict[\"entity_dict_list\"] = entity_dict_list\ncollection_dict[\"entity_obj_list\"] = entity_obj_list\ncollection_dict[\"collection_model\"] = collection_model\ncollections[entity.__collection__] = collection_dict\nsetattr(entity, \"_db\", self)\n# entity._dirty.clear()\nfor _, data in collections.items():\ncollection_model = data.get(\"collection_model\")\nentity_dict_list = data.get(\"entity_dict_list\")\nentity_obj_list = data.get(\"entity_obj_list\")\nres = collection_model.update_many(entity_dict_list, **kwargs)\nfor num, entity in enumerate(entity_obj_list, start=0):\nentity._dirty.clear()\nself._entity_post_process(entity, res[num])\ndispatch(entity, \"post_update\", db=self, result=entity)\nreturn collections\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.create_all","title":"<code>create_all(db_objects)</code>","text":"<p>Create all objects (collections, relations and graphs).</p> <p>Create all objects present in the db_objects list.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def create_all(self, db_objects):\n\"\"\"\n    Create all objects (collections, relations and graphs).\n    Create all objects present in the db_objects list.\n    \"\"\"\n# Collect all graphs\ngraph_objs = [obj for obj in db_objects if hasattr(obj, \"__graph__\")]\nfor graph_obj in graph_objs:\ngraph_info = self._get_graph_info(graph_obj)\nif not graph_info:\n# graph does not exist, create it\nlog.info(\"Creating graph %s\", graph_obj.__graph__)\ngraph_instance = graph_obj(connection=self)\nself.create_graph(graph_instance)\nelse:\n# Graph exists, determine changes and update graph accordingly\nlog.debug(\"Graph %s already exists\", graph_obj.__graph__)\ngraph_instance = graph_obj(connection=self)\nself.update_graph(graph_instance, graph_info)\nexclude_collections = [c[\"name\"] for c in self._db.collections()]\nfor obj in db_objects:\nif hasattr(obj, \"__bases__\") and Collection in obj.__bases__:\nif obj.__collection__ not in exclude_collections:\nlog.info(\"Creating collection %s\", obj.__collection__)\nself.create_collection(obj)\nelse:\nlog.debug(\"Collection %s already exists\", obj.__collection__)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.create_collection","title":"<code>create_collection(collection)</code>","text":"<p>Create a collection</p> Source code in <code>arango_orm/database.py</code> <pre><code>def create_collection(self, collection: Collection):\n\"Create a collection\"\nself._verify_collection(collection)\ncol_args = {}\nif \"col_args\" in collection._collection_config:\ncol_args = collection._collection_config[\"col_args\"]\nif self._verify_relation(collection) and \"edge\" not in col_args:\ncol_args[\"edge\"] = True\ncol = super(Database, self).create_collection(name=collection.__collection__, **col_args)\nif \"indexes\" in collection._collection_config:\nfor index in collection._collection_config[\"indexes\"]:\n# index_type: Literal[\"hash\", \"fulltext\", \"skiplist\", \"geo\", \"persistent\", \"ttl\"]\n# fields: list[str]\n# unique: bool\n# sparse: bool\nindex_create_method_name = \"add_{}_index\".format(index[\"index_type\"])\nd = deepcopy(index)\ndel d[\"index_type\"]\n# create the index\ngetattr(col, index_create_method_name)(**d)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.create_graph","title":"<code>create_graph(graph_object, **kwargs)</code>","text":"<p>Create a named graph from given graph object Optionally can provide a list of collection names as ignore_collections so those collections are not created</p> Source code in <code>arango_orm/database.py</code> <pre><code>def create_graph(self, graph_object: Graph, **kwargs):\n\"\"\"\n    Create a named graph from given graph object\n    Optionally can provide a list of collection names as ignore_collections\n    so those collections are not created\n    \"\"\"\ngraph_edge_definitions = []\n# Create collections manually here so we also create indices\n# defined within the collection class. If we let the create_graph\n# call create the collections, it won't create the indices\nfor _, col_obj in graph_object.vertices.items():\nif (\n\"ignore_collections\" in kwargs\nand col_obj.__collection__ in kwargs[\"ignore_collections\"]\n):\ncontinue\ntry:\nself.create_collection(col_obj)\nexcept Exception:\nlog.warning(\n\"Error creating collection %s, it probably already exists\",\ncol_obj.__collection__,\n)\nfor _, rel_obj in graph_object.edges.items():\nif (\n\"ignore_collections\" in kwargs\nand rel_obj.__collection__ in kwargs[\"ignore_collections\"]\n):\ncontinue\ntry:\nself.create_collection(rel_obj)\nexcept Exception:\nlog.warning(\n\"Error creating edge collection %s, it probably already exists\",\nrel_obj.__collection__,\n)\nfor rel_name, relation_obj in graph_object.edges.items():\ncols_from = graph_object.edge_cols_from[rel_name]\ncols_to = graph_object.edge_cols_to[rel_name]\nfrom_col_names = [col.__collection__ for col in cols_from]\nto_col_names = [col.__collection__ for col in cols_to]\ngraph_edge_definitions.append(\n{\n\"edge_collection\": relation_obj.__collection__,\n\"from_vertex_collections\": from_col_names,\n\"to_vertex_collections\": to_col_names,\n}\n)\nself._db.create_graph(graph_object.__graph__, graph_edge_definitions)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.delete","title":"<code>delete(entity, **kwargs)</code>","text":"<p>Delete given document.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def delete(self, entity: Collection, **kwargs):\n\"\"\"Delete given document.\"\"\"\ndispatch(entity, \"pre_delete\", db=self)\ncollection = self._db.collection(entity.__collection__)\ncollection.delete(entity.key_, **kwargs)\ndispatch(entity, \"post_delete\", db=self, result=entity)\nreturn entity\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.drop_all","title":"<code>drop_all(db_objects)</code>","text":"<p>Drop all objects (collections, relations and graphs).</p> <p>Drop all objects present in the db_objects list.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def drop_all(self, db_objects):\n\"\"\"\n    Drop all objects (collections, relations and graphs).\n    Drop all objects present in the db_objects list.\n    \"\"\"\n# Collect all graphs\ngraph_objs = [obj for obj in db_objects if hasattr(obj, \"__graph__\")]\nfor graph_obj in graph_objs:\ngraph_info = self._get_graph_info(graph_obj)\nif graph_info:\n# graph exists, drop it\nlog.info(\"Dropping graph %s\", graph_obj.__graph__)\ngraph_instance = graph_obj(connection=self)\nself.drop_graph(graph_instance)\nelse:\n# Graph exists, determine changes and update graph accordingly\nlog.debug(\"Graph %s does not exist\", graph_obj.__graph__)\nfor obj in db_objects:\nif hasattr(obj, \"__bases__\") and Collection in obj.__bases__:\ntry:\nself.drop_collection(obj)\nexcept CollectionDeleteError:\nlog.debug(\n\"Not deleting missing collection: %s\",\nobj.__collection__,\n)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.drop_collection","title":"<code>drop_collection(collection)</code>","text":"<p>Drop a collection</p> Source code in <code>arango_orm/database.py</code> <pre><code>def drop_collection(self, collection):\n\"Drop a collection\"\nself._verify_collection(collection)\nsuper(Database, self).delete_collection(name=collection.__collection__)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.drop_graph","title":"<code>drop_graph(graph_object, drop_collections=True, **kwargs)</code>","text":"<p>Drop a graph.</p> <p>If drop_collections is True, drop all vertices and edges too. Optionally can provide a list of collection names as ignore_collections so those collections are not dropped</p> Source code in <code>arango_orm/database.py</code> <pre><code>def drop_graph(self, graph_object, drop_collections=True, **kwargs):\n\"\"\"\n    Drop a graph.\n    If drop_collections is True, drop all vertices and edges\n    too. Optionally can provide a list of collection names as\n    ignore_collections so those collections are not dropped\n    \"\"\"\nself._db.delete_graph(\ngraph_object.__graph__,\nignore_missing=True,\ndrop_collections=drop_collections,\n)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.exists","title":"<code>exists(document)</code>","text":"<p>Check if document exists in database.</p> <p>Similar to has but takes in a document object and searches using it's _key.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def exists(self, document):\n\"\"\"\n    Check if document exists in database.\n    Similar to has but takes in a document object and searches\n    using it's _key.\n    \"\"\"\nreturn self._db.collection(document.__collection__).has(document.key_)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.has","title":"<code>has(collection, key)</code>","text":"<p>Check if the document with key exists in the given collection.</p> Source code in <code>arango_orm/database.py</code> <pre><code>def has(self, collection, key):\n\"\"\"Check if the document with key exists in the given collection.\"\"\"\nreturn self._db.collection(collection.__collection__).has(key)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.has_collection","title":"<code>has_collection(collection)</code>","text":"<p>Confirm that the given collection class or collection name exists in the db</p> Source code in <code>arango_orm/database.py</code> <pre><code>def has_collection(self, collection):\n\"Confirm that the given collection class or collection name exists in the db\"\ncollection_name = None\nif isclass(collection) and hasattr(collection, \"__collection__\"):\ncollection_name = collection.__collection__\nelif isinstance(collection, str):\ncollection_name = collection\nassert collection_name is not None\nreturn self._db.has_collection(collection_name)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.query","title":"<code>query(CollectionClass)</code>","text":"<p>Query given collection</p> Source code in <code>arango_orm/database.py</code> <pre><code>def query(self, CollectionClass) -&gt; Query:\n\"Query given collection\"\nreturn Query(CollectionClass, self)\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.update","title":"<code>update(entity, only_dirty=False, **kwargs)</code>","text":"<p>Update given document</p> Source code in <code>arango_orm/database.py</code> <pre><code>def update(self, entity, only_dirty=False, **kwargs):\n\"Update given document\"\ncollection = self._db.collection(entity.__collection__)\ndata = {}\nif only_dirty:\nif not entity._dirty:\nreturn entity\ndispatch(entity, \"pre_update\", db=self)  # In case of updates to fields\ndata = {\nk: v\nfor k, v in entity.model_dump(mode=\"json\", by_alias=True).items()\nif k == \"_key\" or k in entity._dirty\n}\nelse:\ndispatch(entity, \"pre_update\", db=self)\ndata = entity.model_dump(mode=\"json\", by_alias=True)\nsetattr(entity, \"_db\", self)\nself._entity_pre_process(data)\nres = collection.update(data, **kwargs)\nentity._dirty.clear()\nself._entity_post_process(entity, res)\ndispatch(entity, \"post_update\", db=self, result=entity)\nreturn entity\n</code></pre>"},{"location":"reference/#arango_orm.database.Database.update_graph","title":"<code>update_graph(graph_object, graph_info=None)</code>","text":"<p>Update existing graph object by adding collections and edge collections that are present in graph definition but not present within the graph in the database.</p> <p>Note: We delete edge definitions if they no longer exist in the graph class but we don't drop collections</p> Source code in <code>arango_orm/database.py</code> <pre><code>def update_graph(self, graph_object: Graph, graph_info=None):\n\"\"\"\n    Update existing graph object by adding collections and edge collections\n    that are present in graph definition but not present within the graph\n    in the database.\n    Note: We delete edge definitions if they no longer exist in the graph\n    class but we don't drop collections\n    \"\"\"\nif graph_info is None:\ngraph_info = self._get_graph_info(graph_object)\n# Create collections manually here so we also create indices\n# defined within the collection class. If we let the create_graph\n# call create the collections, it won't create the indices\nexisting_collection_names = [c[\"name\"] for c in self.collections()]\nfor _, col_obj in graph_object.vertices.items():\ntry:\nif col_obj.__collection__ in existing_collection_names:\nlog.debug(\"Collection %s already exists\", col_obj.__collection__)\ncontinue\nlog.info(\"+ Creating collection %s\", col_obj.__collection__)\nself.create_collection(col_obj)\nexcept Exception:\nlog.warning(\n\"Error creating collection %s, it probably already exists\",\ncol_obj.__collection__,\n)\nfor _, rel_obj in graph_object.edges.items():\ntry:\nif rel_obj.__collection__ in existing_collection_names:\nlog.debug(\"Collection %s already exists\", rel_obj.__collection__)\ncontinue\nlog.info(\"+ Creating edge collection %s\", rel_obj.__collection__)\nself.create_collection(rel_obj, edge=True)\nexcept Exception:\nlog.warning(\n\"Error creating edge collection %s, it probably already exists\",\nrel_obj.__collection__,\n)\nexisting_edges = dict(\n[(e[\"edge_collection\"], e) for e in graph_object._graph.edge_definitions()]\n)\nfor rel_name, relation in graph_object.edges.items():\ncols_from = graph_object.edge_cols_from[rel_name]\ncols_to = graph_object.edge_cols_to[rel_name]\nfrom_col_names = [col.__collection__ for col in cols_from]\nto_col_names = [col.__collection__ for col in cols_to]\nedge_definition = {\n\"edge_collection\": relation.__collection__,\n\"from_vertex_collections\": from_col_names,\n\"to_vertex_collections\": to_col_names,\n}\n# if edge does not already exist, create it\nif edge_definition[\"edge_collection\"] not in existing_edges:\nlog.info(\"  + creating graph edge definition: %r\", edge_definition)\ngraph_object._graph.create_edge_definition(**edge_definition)\nelse:\n# if edge definition exists, see if it needs updating\n# compare edges\nif not self._is_same_edge(\nedge_definition,\nexisting_edges[edge_definition[\"edge_collection\"]],\n):\n# replace_edge_definition\nlog.info(\n\"  graph edge definition modified, updating:\\n new: %r\\n old: %r\",\nedge_definition,\nexisting_edges[edge_definition[\"edge_collection\"]],\n)\ngraph_object._graph.replace_edge_definition(**edge_definition)\n# Remove any edge definitions that are present in DB but not in graph definition\ngraph_connections = dict(\n[(gc.relation.__collection__, gc) for gc in graph_object.graph_connections]\n)\nfor edge_name, ee in existing_edges.items():\nif edge_name not in graph_connections:\nlog.warning(\n\"  - dropping edge no longer present in graph definition. \"\n\"Please drop the edge and vertex collections manually if you no \"\n\"longer need them: \\n%s\",\nee,\n)\ngraph_object._graph.delete_edge_definition(edge_name)\n</code></pre>"},{"location":"reference/#collection","title":"Collection","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>arango_orm/collections.py</code> <pre><code>class Collection(BaseModel):\n__collection__ = None\n_safe_list: ClassVar[list[str]] = [\n\"__collection__\",\n\"_safe_list\",\n\"_annotated_fields\"\n\"_relations\",\n\"_index\",\n\"config_\",\n\"_collections_from\",\n\"_collections_to\",\n\"_object_from\",\n\"_object_to\",\n\"_post_process\",\n\"_pre_process\",\n\"_fields_info\",\n\"_fields\",\n\"_db\",\n\"_refs\",\n\"_refs_vals\",\n\"model_config\",  # pydantic configuration attribute\n]\n_annotated_fields: ClassVar[list[str]] = []\nmodel_config: ClassVar[dict] = ConfigDict(\npopulate_by_name=True,\narbitrary_types_allowed=True,\nignored_types=(Relationship,),\n)\n_collection_config: ClassVar[dict] = CollectionConfig()\n_dirty: set\n_db: Database | None\n_fields: dict\n_refs: dict\n_refs_vals: dict\nkey_: str = Field(None, alias=\"_key\")\nrev_: str = Field(None, alias=\"_rev\")\ndef __init__(self, collection_name=None, **kwargs):\nif \"_key\" in kwargs:\nkwargs[\"key_\"] = kwargs[\"_key\"]\ndel kwargs[\"_key\"]\nif \"_id\" in kwargs:\ndel kwargs[\"_id\"]\n# if self._collection_config.get(\"key_field\", None) and 'key_' not in kwargs:\n#     kwargs[\"key_\"] = kwargs[self._collection_config[\"key_field\"]]\nsuper().__init__(**kwargs)\nif collection_name is not None:\nself.__collection__ = collection_name\n# Determine actual data fields.\nself._fields = {}\nself._refs_vals: dict = {}  # Storage for referenced objects\nself._refs: dict[str, FieldInfo] = {}\nfor fname, f in self.model_fields.items():\nif f.default.__class__ in self.model_config.get(\"ignored_types\", []):\nif f.default.__class__ is Relationship:\nself._refs[fname] = f\ncontinue\nif fname in self._annotated_fields:\ncontinue\nself._fields[fname] = f\nself._dirty = set(self._fields.keys())\nself._db = kwargs.get(\"_db\", None)\nif self._db is not None:\nself._dirty = set()\ndef __str__(self):\nreturn f\"{self.__class__.__name__}({super().__str__()})\"\n@property\ndef id_(self) -&gt; str | None:\nif self._key is not None and self.__collection__ is not None:\nreturn f\"{self.__collection__}/{self._key}\"\n# if hasattr(self, \"_key\") and getattr(self, \"_key\") is not None:\n#     return self.__collection__ + \"/\" + getattr(self, \"_key\")\nreturn None\n@property\ndef _id(self) -&gt; str | None:\nreturn self.id_\n@property\ndef _key(self) -&gt; str | None:\nreturn self.key_\n@_key.setter\ndef _key(self, value):\nself.key_ = value\n@property\ndef _rev(self) -&gt; str | None:\nreturn self.rev_\n@_rev.setter\ndef _rev(self, value):\nself.rev_ = value\ndef __setattr__(self, attr, value):\na_real = attr\n# if attr == self.config_.get(\"key_field\", None):\n#     a_real = \"key_\"\nif attr == \"_id\":\nreturn\nif \"_key\" == attr:\na_real = \"key_\"\nsuper().__setattr__(a_real, value)\nif a_real not in self.model_fields_set:\nreturn\nself._dirty.add(a_real)\ndef __getattribute__(self, item: str):\nif item in [\"_id\", \"id_\"]:\nreturn super().__getattribute__(\"id_\")\nif item == \"_key\":\nreturn super().__getattribute__(\"key_\")\nif item.startswith((\"_\", \"model_\") or item in self._annotated_fields):\nreturn super().__getattribute__(item)\nif item in self._safe_list:\nreturn super().__getattr__(item)\nif item not in self.model_fields:\nraise AttributeError(name=item, obj=self)\nif item not in self._refs:\nreturn super().__getattribute__(item)\n# Item is a relationship so we need to lookit up and return proper value.\nif item in self._refs_vals:\nreturn self._refs_vals[item]\nif self._db is None:\nraise DetachedInstanceError()\nrelationship: Relationship = self._refs[item].default\nReferencedClass = relationship.col_class\nr_val = None\nif \"key_\" == relationship.target_field:\nr_val = self._db.query(ReferencedClass).by_key(\ngetattr(self, relationship.field)\n# super(Collection, self).__getattribute__(ref_class.field)\n)\nif relationship.uselist is True:\nr_val = [\nr_val,\n]\nelse:\nquery = self._db.query(ReferencedClass).filter(\nrelationship.target_field + \"==@val\",\nval=getattr(self, relationship.field),\n)\nif relationship.uselist is False:\nr_val = query.first()\nelse:\n# TODO: Handle ref_class.order_by if present\nr_val = query.all()\nif relationship.cache is True:\nself._refs_vals[item] = r_val\nreturn r_val\ndef model_dump(\nself,\n*,\nmode: Literal[\"json\", \"python\"] | str = \"python\",\ninclude: IncEx = None,\nexclude: IncEx = None,\nby_alias: bool = False,\nexclude_unset: bool = False,\nexclude_defaults: bool = False,\nexclude_none: bool = False,\nround_trip: bool = False,\nwarnings: bool = True,\n) -&gt; dict[str, Any]:\nexclude = exclude or set()\nexclude_fields = {\"_db\", \"_refs\"}\nif exclude:\nexclude = set(exclude)\nexclude.update(exclude_fields)\nelse:\nexclude = exclude_fields\nfor fname in self.model_fields:\nif fname not in self._fields:\nexclude.add(fname)\nreturn super().model_dump(\nmode=mode,\ninclude=include,\nexclude=exclude,\nby_alias=by_alias,\nexclude_unset=exclude_unset,\nexclude_defaults=exclude_defaults,\nexclude_none=exclude_none,\nround_trip=round_trip,\nwarnings=warnings,\n)\n</code></pre>"},{"location":"reference/#relation","title":"Relation","text":"<p>             Bases: <code>Collection</code></p> Source code in <code>arango_orm/collections.py</code> <pre><code>class Relation(Collection):\nfrom_: str | None = Field(None, alias=\"_from\")\nto_: str | None = Field(None, alias=\"_to\")\n_collections_from: Collection | list[Collection] | None\n_collections_to: Collection | list[Collection] | None\ndef __init__(self, collection_name=None, **kwargs):\nif \"_from\" in kwargs:\nkwargs[\"from_\"] = kwargs[\"_from\"]\ndel kwargs[\"_from\"]\nif \"_to\" in kwargs:\nkwargs[\"to_\"] = kwargs[\"_to\"]\ndel kwargs[\"_to\"]\nsuper().__init__(collection_name=collection_name, **kwargs)\nif \"_collections_from\" in kwargs:\nself._collections_from = kwargs[\"_collections_from\"]\ndel kwargs[\"_collections_from\"]\nelse:\nself._collections_from = None\nif \"_collections_to\" in kwargs:\nself._collections_to = kwargs[\"_collections_to\"]\ndel kwargs[\"_collections_to\"]\nelse:\nself._collections_to = None\nself._object_from = None\nself._object_to = None\n@property\ndef _from(self) -&gt; str | None:\nreturn self.from_\n@_from.setter\ndef _from(self, value):\nself.from_ = value\n@property\ndef _to(self) -&gt; str | None:\nreturn self.to_\n@_to.setter\ndef _to(self, value):\nself.to_ = value\n</code></pre>"},{"location":"reference/#graph","title":"Graph","text":"<p>             Bases: <code>object</code></p> Source code in <code>arango_orm/graph.py</code> <pre><code>class Graph(object):\n__graph__ = None\ngraph_connections = None\ndef __init__(self, graph_name=None, graph_connections=None, connection=None):\nself.vertices = {}\nself.edges: dict[str, Relation] = {}\nself.edge_cols_from: dict[str, list[Collection]] = {}\nself.edge_cols_to: dict[str, list[Collection]] = {}\nself._db = connection\nself._graph = None\nself.inheritances = {}\nif graph_name is not None:\nself.__graph__ = graph_name\nif self._db is not None:\nself._graph = self._db.graph(self.__graph__)\nif graph_connections:\nself.graph_connections = graph_connections\nif self.graph_connections:\nfor gc in self.graph_connections:\nfroms = gc.collections_from\nif not isinstance(froms, (list, tuple)):\nfroms = [\nfroms,\n]\ntos = gc.collections_to\nif not isinstance(tos, (list, tuple)):\ntos = [\ntos,\n]\n# Note: self.vertices stores collection classes while self.edges stores\n# relation objects (not classes)\nfor col in froms + tos:\nif col.__collection__ not in self.vertices:\nself.vertices[col.__collection__] = col\nif gc.relation.__collection__ not in self.edges:\nself.edges[gc.relation.__collection__] = gc.relation\nself.edge_cols_from[gc.relation.__collection__] = froms\nself.edge_cols_to[gc.relation.__collection__] = tos\n# for col_name, col in [\n#     (col_name, col)\n#     for col_name, col in self.vertices.items()\n#     if len(col._inheritance_mapping) &gt; 0\n# ]:\n#     subclasses = self._get_recursive_subclasses(col).union([col])\n#     if len(subclasses) &gt; 1:\n#         _inheritances = {}\n#         for subclass in [\n#             subclass\n#             for subclass in subclasses\n#             if subclass.__name__ in col._inheritance_mapping\n#         ]:\n#             _inheritances[col._inheritance_mapping[subclass.__name__]] = subclass\n#         if len(_inheritances):\n#             self.inheritances[col_name] = _inheritances\n# def _get_recursive_subclasses(self, cls):\n#     return set(cls.__subclasses__()).union(\n#         [s for c in cls.__subclasses__() for s in self._get_recursive_subclasses(c)]\n#     )\ndef relation(self, relation_from, relation, relation_to):\n\"\"\"\n        Return relation (edge) object from given collection (relation_from and\n        relation_to) and edge/relation (relation) objects\n        \"\"\"\n# relation._from = relation_from.__collection__ + '/' + relation_from._key\n# relation._to = relation_to.__collection__ + '/' + relation_to._key\nrelation.from_ = relation_from.id_\nrelation.to_ = relation_to.id_\nreturn relation\ndef _inheritance_mapping_inspector(self, collection_class: Collection, doc_dict: dict):\nfield = collection_class._inheritance_field\nmapping = self.inheritances[collection_class.__collection__]\nif doc_dict[field] not in mapping or not issubclass(mapping[doc_dict[field]], Collection):\nreturn False\nreturn mapping[doc_dict[field]]\ndef inheritance_mapping_resolver(self, col_name: str, doc_dict) -&gt; Type[Collection]:\n\"\"\"\n        Custom method to resolve inheritance mapping.\n        It allows the user to resolve the class of the current object based on any condition (discriminator field a/o\n        inference).\n        :param col_name: The collection name retrieved from the object _id property\n        :param doc_dict: The object as dict\n        :return Type[Collection]\n        \"\"\"\nreturn self.vertices[col_name]\ndef _doc_from_dict(self, doc_dict):\n\"Given a result dictionary, creates and returns a document object\"\ncol_name = doc_dict[\"_id\"].split(\"/\")[0]\nCollectionClass = self.vertices[col_name]\nif CollectionClass.__collection__ in self.inheritances:\nfound_class = self._inheritance_mapping_inspector(CollectionClass, doc_dict)\nif issubclass(found_class, Collection):\nCollectionClass = found_class\nelif callable(self.inheritance_mapping_resolver):\nresolved_class = self.inheritance_mapping_resolver(col_name, doc_dict)\nif issubclass(resolved_class, Collection):\nCollectionClass = resolved_class\n# remove empty values\nkeys_to_del = []\nfor k, v in doc_dict.items():\nif doc_dict[k] is None:\nkeys_to_del.append(k)\nif keys_to_del:\nfor k in keys_to_del:\ndel doc_dict[k]\nreturn CollectionClass(**doc_dict)\ndef _objectify_results(self, results, doc_obj=None):\n\"\"\"\n        Make traversal results object oriented by adding all links to the first\n        object's _relations attribute. If doc_obj is not provided, the first\n        vertex of the first path is used.\n        \"\"\"\n# Create objects from vertices dicts\ndocuments = {}\nif doc_obj:\ndocuments[doc_obj.id_] = doc_obj\nrelations_added = {}\nfor p_dict in results:\nfor v_dict in p_dict[\"vertices\"]:\nif doc_obj is None:\n# Get the first vertex of the first result, it's the parent object\ndoc_obj = self._doc_from_dict(v_dict)\ndocuments[doc_obj.id_] = doc_obj\nif v_dict[\"_id\"] in documents:\ncontinue\n# Get ORM class for the collection\ndocuments[v_dict[\"_id\"]] = self._doc_from_dict(v_dict)\n# Process each path as a unit\n# First edge's _from always points to our parent document\nparent_id = doc_obj.id_\nfor e_dict in p_dict[\"edges\"]:\ncol_name = e_dict[\"_id\"].split(\"/\")[0]\nrel_identifier = parent_id + \"-&gt;\" + e_dict[\"_id\"]\nif rel_identifier in relations_added:\nrel = relations_added[rel_identifier]\nelse:\nRelationClass = self.edges[col_name]\nif not isclass(self.edges[col_name]):\nRelationClass = RelationClass.__class__\nrel = RelationClass(**e_dict)\nrel._object_from = documents[rel.from_]\nrel._object_to = documents[rel.to_]\nparent_object = None\nif rel.from_ == parent_id:\nparent_object = documents[rel.from_]\nrel._next = rel._object_to\nelif rel.to_ == parent_id:\nparent_object = documents[rel.to_]\nrel._next = rel._object_from\nassert parent_object is not None\nif not hasattr(parent_object, \"_relations\"):\nsetattr(parent_object, \"_relations\", {})\nif col_name not in parent_object._relations:\nparent_object._relations[col_name] = []\nif rel not in parent_object._relations[col_name]:\nparent_object._relations[col_name].append(rel)\nif rel.id_ not in relations_added:\nrelations_added[rel_identifier] = rel\n# Set parent ID\nif rel.from_ == parent_id:\nparent_id = rel.to_\nelif rel.to_ == parent_id:\nparent_id = rel.from_\nreturn doc_obj\ndef expand(self, doc_obj, direction=\"any\", depth=1, only=None, condition:str = None):\n\"\"\"\n        Graph traversal.\n        Expand all links of given direction (outbound, inbound, any) upto given\n        length for the given document object and update the object with the\n        found relations.\n        :param only: If given should be a string, Collection class or list of\n        strings or collection classes containing target collection names of\n        documents (vertices) that should be fetched.\n        Any vertices found in traversal that don't belong to the specified\n        collection names given in this parameter will be ignored.\n        :param condition: String containing conditions in JS format. If `only` is provided\n        then these conditions are merged with only using logical AND. Within the condition\n        3 objects (config, vertex, path) are available for use within the traversal context.\n        \"\"\"\nassert direction in (\"any\", \"inbound\", \"outbound\")\ngraph = self._db.graph(self.__graph__)\ndoc_id = doc_obj.id_\ndoc_obj._relations = {}  # clear any previous relations\nfilter_func = None\nc_str = \"\"\naql = f\"FOR vertex, edge, path IN 1..{depth} {direction} '{doc_id}' GRAPH {self.__graph__}\\n\"\nif only:\nif not isinstance(only, (list, tuple)):\nonly = [\nonly,\n]\nfor c in only:\nif not isinstance(c, str) and hasattr(c, \"__collection__\"):\nc = c.__collection__\nc_str += \"vertex._id LIKE '\" + c + \"/%' ||\"\nif c_str:\nc_str = c_str[:-3]\nif condition:\nif c_str:\nc_str = c_str + ' AND ' + condition\nelse:\nc_str = condition\nif c_str:\naql += \"FILTER \" + c_str + \"\\n\"\naql += \"RETURN path\"\n# print(aql)\nnew_doc = self.aql(aql)\nif new_doc:\ndoc_obj._relations = new_doc._relations\n# results = graph.traverse(\n#     start_vertex=doc_id,\n#     direction=direction,\n#     vertex_uniqueness=\"path\",\n#     min_depth=1,\n#     max_depth=depth,\n#     filter_func=filter_func,\n# )\n# self._objectify_results(results[\"paths\"], doc_obj)\ndef aql(self, query, **kwargs):\n\"\"\"Run AQL graph traversal query.\"\"\"\nresults = self._db.aql.execute(query, **kwargs)\ndoc_obj = self._objectify_results(results)\nreturn doc_obj\ndef delete_tree(self, doc_obj):\n\"\"\"\n        Remove node and all nodes linked to it based on traversal criteria.\n        Only nodes present in doc_obj._relations dict are removed.\n        \"\"\"\nobjs_to_delete = [doc_obj]\ndef get_linked_objects(obj):\nret = []\nfor _, e_objs in getattr(obj, \"_relations\", {}).items():\nfor e_obj in e_objs:\nret.append(e_obj)\nv_obj = e_obj._next\nret.append(v_obj)\nif hasattr(v_obj, \"_relations\"):\n_ = get_linked_objects(v_obj)\nreturn ret\nif hasattr(doc_obj, \"_relations\"):\nobjs_to_delete.extend(get_linked_objects(doc_obj))\nfor obj in reversed(objs_to_delete):\nself._db.delete(obj)\ndoc_obj._relations = {}\n</code></pre>"},{"location":"reference/#arango_orm.graph.Graph.aql","title":"<code>aql(query, **kwargs)</code>","text":"<p>Run AQL graph traversal query.</p> Source code in <code>arango_orm/graph.py</code> <pre><code>def aql(self, query, **kwargs):\n\"\"\"Run AQL graph traversal query.\"\"\"\nresults = self._db.aql.execute(query, **kwargs)\ndoc_obj = self._objectify_results(results)\nreturn doc_obj\n</code></pre>"},{"location":"reference/#arango_orm.graph.Graph.delete_tree","title":"<code>delete_tree(doc_obj)</code>","text":"<p>Remove node and all nodes linked to it based on traversal criteria.</p> <p>Only nodes present in doc_obj._relations dict are removed.</p> Source code in <code>arango_orm/graph.py</code> <pre><code>def delete_tree(self, doc_obj):\n\"\"\"\n    Remove node and all nodes linked to it based on traversal criteria.\n    Only nodes present in doc_obj._relations dict are removed.\n    \"\"\"\nobjs_to_delete = [doc_obj]\ndef get_linked_objects(obj):\nret = []\nfor _, e_objs in getattr(obj, \"_relations\", {}).items():\nfor e_obj in e_objs:\nret.append(e_obj)\nv_obj = e_obj._next\nret.append(v_obj)\nif hasattr(v_obj, \"_relations\"):\n_ = get_linked_objects(v_obj)\nreturn ret\nif hasattr(doc_obj, \"_relations\"):\nobjs_to_delete.extend(get_linked_objects(doc_obj))\nfor obj in reversed(objs_to_delete):\nself._db.delete(obj)\ndoc_obj._relations = {}\n</code></pre>"},{"location":"reference/#arango_orm.graph.Graph.expand","title":"<code>expand(doc_obj, direction='any', depth=1, only=None, condition=None)</code>","text":"<p>Graph traversal.</p> <p>Expand all links of given direction (outbound, inbound, any) upto given length for the given document object and update the object with the found relations.</p> <p>:param only: If given should be a string, Collection class or list of strings or collection classes containing target collection names of documents (vertices) that should be fetched. Any vertices found in traversal that don't belong to the specified collection names given in this parameter will be ignored.</p> <p>:param condition: String containing conditions in JS format. If <code>only</code> is provided then these conditions are merged with only using logical AND. Within the condition 3 objects (config, vertex, path) are available for use within the traversal context.</p> Source code in <code>arango_orm/graph.py</code> <pre><code>def expand(self, doc_obj, direction=\"any\", depth=1, only=None, condition:str = None):\n\"\"\"\n    Graph traversal.\n    Expand all links of given direction (outbound, inbound, any) upto given\n    length for the given document object and update the object with the\n    found relations.\n    :param only: If given should be a string, Collection class or list of\n    strings or collection classes containing target collection names of\n    documents (vertices) that should be fetched.\n    Any vertices found in traversal that don't belong to the specified\n    collection names given in this parameter will be ignored.\n    :param condition: String containing conditions in JS format. If `only` is provided\n    then these conditions are merged with only using logical AND. Within the condition\n    3 objects (config, vertex, path) are available for use within the traversal context.\n    \"\"\"\nassert direction in (\"any\", \"inbound\", \"outbound\")\ngraph = self._db.graph(self.__graph__)\ndoc_id = doc_obj.id_\ndoc_obj._relations = {}  # clear any previous relations\nfilter_func = None\nc_str = \"\"\naql = f\"FOR vertex, edge, path IN 1..{depth} {direction} '{doc_id}' GRAPH {self.__graph__}\\n\"\nif only:\nif not isinstance(only, (list, tuple)):\nonly = [\nonly,\n]\nfor c in only:\nif not isinstance(c, str) and hasattr(c, \"__collection__\"):\nc = c.__collection__\nc_str += \"vertex._id LIKE '\" + c + \"/%' ||\"\nif c_str:\nc_str = c_str[:-3]\nif condition:\nif c_str:\nc_str = c_str + ' AND ' + condition\nelse:\nc_str = condition\nif c_str:\naql += \"FILTER \" + c_str + \"\\n\"\naql += \"RETURN path\"\n# print(aql)\nnew_doc = self.aql(aql)\nif new_doc:\ndoc_obj._relations = new_doc._relations\n</code></pre>"},{"location":"reference/#arango_orm.graph.Graph.inheritance_mapping_resolver","title":"<code>inheritance_mapping_resolver(col_name, doc_dict)</code>","text":"<p>Custom method to resolve inheritance mapping.</p> <p>It allows the user to resolve the class of the current object based on any condition (discriminator field a/o inference).</p> <p>:param col_name: The collection name retrieved from the object _id property :param doc_dict: The object as dict :return Type[Collection]</p> Source code in <code>arango_orm/graph.py</code> <pre><code>def inheritance_mapping_resolver(self, col_name: str, doc_dict) -&gt; Type[Collection]:\n\"\"\"\n    Custom method to resolve inheritance mapping.\n    It allows the user to resolve the class of the current object based on any condition (discriminator field a/o\n    inference).\n    :param col_name: The collection name retrieved from the object _id property\n    :param doc_dict: The object as dict\n    :return Type[Collection]\n    \"\"\"\nreturn self.vertices[col_name]\n</code></pre>"},{"location":"reference/#arango_orm.graph.Graph.relation","title":"<code>relation(relation_from, relation, relation_to)</code>","text":"<p>Return relation (edge) object from given collection (relation_from and relation_to) and edge/relation (relation) objects</p> Source code in <code>arango_orm/graph.py</code> <pre><code>def relation(self, relation_from, relation, relation_to):\n\"\"\"\n    Return relation (edge) object from given collection (relation_from and\n    relation_to) and edge/relation (relation) objects\n    \"\"\"\n# relation._from = relation_from.__collection__ + '/' + relation_from._key\n# relation._to = relation_to.__collection__ + '/' + relation_to._key\nrelation.from_ = relation_from.id_\nrelation.to_ = relation_to.id_\nreturn relation\n</code></pre>"},{"location":"reference/#events","title":"Events","text":""},{"location":"reference/#arango_orm.event.dispatch","title":"<code>dispatch(target, event, *args, **kwargs)</code>","text":"<p>Fire given event</p> Source code in <code>arango_orm/event.py</code> <pre><code>def dispatch(target, event, *args, **kwargs):\n\"Fire given event\"\nby_event = _registrars[event]\nfor t in by_event.keys():\nif isinstance(target, t):\nfor fn in by_event[t]:\nfn(target, event, *args, **kwargs)\n</code></pre>"},{"location":"reference/#arango_orm.event.listen","title":"<code>listen(target, event, fn, *args, **kwargs)</code>","text":"<p>Register fn to listen for event</p> Source code in <code>arango_orm/event.py</code> <pre><code>def listen(target, event, fn, *args, **kwargs):\n\"Register fn to listen for event\"\nevents = [event] if isinstance(event, six.text_type) else event\nfor event in events:\n_registrars[event][target].append(fn)\n</code></pre>"},{"location":"reference/#arango_orm.event.listens_for","title":"<code>listens_for(target, event, *args, **kwargs)</code>","text":"<p>Decorator to register fn to listen for event</p> Source code in <code>arango_orm/event.py</code> <pre><code>def listens_for(target, event, *args, **kwargs):\n\"Decorator to register fn to listen for event\"\ndef decorator(fn):\nlisten(target, event, fn, *args, **kwargs)\nreturn fn\nreturn decorator\n</code></pre>"},{"location":"referenced-objects/","title":"Referencing objects from other collection","text":"<p>The relationship links one of the collection fields to data in other collections. The referenced object can then be accessed as a property of the current object.</p>"},{"location":"referenced-objects/#example","title":"Example","text":"<pre><code>    from pydantic import BaseModel, ConfigDict, Field\nfrom arango_orm.references import relationship, graph_relationship, Relationship\nfrom arango_orm import Collection, Relation, Graph, GraphConnection\nclass Person(Collection):\n__collection__ = \"persons\"\nkey_: str = Field(None, alias=\"_key\")\nname: str\ncars: list[\"Car\"] = relationship(__name__ + \".Car\", \"key_\", target_field=\"owner_key\")\nclass Car(Collection):\n__collection__ = \"cars\"\nmake: str\nmodel: str\nyear: int\nowner_key: str | None = None\nowner: Person = relationship(Person, \"owner_key\")\ndb.add(Person(key_=\"ABC\", name=\"Mr. ABC\"))\ndb.add(Car(make=\"Honda\", model=\"Civic\", year=1984, owner_key=\"ABC\"))\ndb.add(Car(make=\"Toyota\", model=\"Corolla\", year=1988, owner_key=\"ABC\"))\np = db.query(Person).by_key('ABC')\nprint(len(p.cars))  # 4\ncar1 = db.query(Car).first()\nprint(car1.owner.name)  # Mr. ABC\n</code></pre>"},{"location":"referenced-objects/#caching","title":"Caching","text":"<p>The referenced object is cached in the current object when the current object is fetched from the database. Future access to the reference does not require a call to the database. This behavior can be disabled by passing <code>cache=False</code> to the <code>relationship</code> function.</p>"}]}